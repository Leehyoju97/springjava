## SRP(Single Responsibility Principle) 단일 책임 원칙
- 하나의 클래스가 하나의 책임(기능)을 가진다.
- 예를 들어 Car가 있으면 Car가 가지고 있는 기능만을 책임지는 것을 의미한다.

## OCP(Open Close Principle) 개방 폐쇄 원칙
- 소프트웨어 엔티티(클래스, 모듈, 함수)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다.
- 기능을 추가할 때 기존의 코드를 변경하지 않고도 추가할 수 있어야 한다는 의미이다.
- 예를 들어 Car라는 상위클래스가 존재하고 최고속도라는 기능이 있을 때 차종마다 최고속도가 다를 것이다. Car 클래스를 상속받는 아반떼 클래스, 소나타 클래스가 존재하는데 bmw의 최고속도를 원할 경우 기존 코드는 그대로 두고 bmw라는 클래스가 Car라는 클래스를 상속 받은 후 코드를 작성하는 형식을 들 수 있다.

## LSP(Liskov Substituition Principle) 리스코프 치환 원칙
- 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다.
- 하위 클래스 is a kind of 상위클래스 : 하위 분류는 상위 분류의 한 종류다.
- 구현 클래스 is able to 인터페이스 : 구현 분류는 인터페이스 할 수 있어야 한다.
- 예를 들어 가족 계층도/조직도는 리스코프 치환 원칙에 어긋나고 동물 분류도가 리스코프 치환 원칙에 적절한 예라고 볼 수 있다.

## ISP(Interface Segregation Principle) : 인터페이스 분리 원칙
- 인터페이스 최소주의 원칙을 지키면서 기능을 인터페이스로 분리하는 것을 의미한다.
- 인터페이스 최소주의 원칙 - 인터페이스를 통해 메서드를 외부에 제공할 때는 최소한의 메서드만 제공하라는 것
- 예를 들어, 자동차라는 인터페이스를 운전, 정비 인터페이스로 각각 분리한다. 사용자 클라이언트는 운전자, 정비사 클라이언트로 각각 분리된다면 정비 인터페이스가 변경되어도 운전자 클라이언트에 영향을 주지 않는다.

## DIP(Dependency Inversion Principle) : 의존 역전 원칙
- 상위클래스에 의존하라는 원칙을 말한다. 즉 자신보다 변하기 쉬운 것에 의존하지 말라는 뜻이다.
- 예를 들어 스노우타이어, 일반타이어를 타이어라는 클래스에 의존을 하면 의존 역전 원칙이 적용된 것이다.


## 어탭터 패턴
- 합성, 즉 객체를 속성으로 만들어서 참조하는 디자인 패턴
- 호출당하는 쪽의 메서드를 호출하는 쪽의 코드에 대응하도록 중간에 변환기를 통해 호출하는 패턴
- 변환기의 역할은 서로 다른 두 인터페이스 사이에 통신이 가능하게 하는 것
- 예를 들어 휴대폰을 직접 전원 콘센트에 연결할 수 없기 때문에 충전기로 휴대폰과 전원 콘센트를 연결해준다.

## 프록시 패턴
- 프록시는 대리자, 대변인(다른 누군가를 대신해 그 역할을 수행하는 존재)이라는 뜻을 가진다.
- 대리자는 실제 서비스와 같은 이름의 메서드를 구현하는데, 이를 위해 인터페이스를 사용한다.
- 대리자는 실제 서비스에 대한 참조 변수를 갖는다.(합성)
- 대리자는 실제 서비스의 같은 이름을 가진 메서드를 호출하고 그 값을 클라이언트에게 돌려준다.
- 대리자는 실제 서비스의 메서드 호출 전후에 별도의 로직을 수행할 수도 있다.
- 프록시 패턴은 실제 서비스 메서드의 반환값에 가감하는 것을 목적으로 하지 않고 제어의 흐름을 변경하거나 다른 로직을 수행하기 위해 사용
- 제어 흐름을 조정하기 위한 목적으로 중간에 대리자를 두는 패턴

## 데코레이터 패턴
- 데코레이터 패턴은 클라이언트가 받는 반환값에 장식을 더한다는 점만 빼면 프록시 패턴과 동일
- 장식자는 실제 서비스와 같은 이름의 메서드를 구현한다. 이때 인터페이스를 사용한다.
- 장식자는 실제 서비스에 대한 참조 변수를 갖는다(합성).
- 장식자는 실제 서비스의 같은 이름을 가진 메서드를 호출하고, 그 반환값에 장식을 더해 클라이언트에게 돌려준다.
- 장식자는 실제 서비스의 메서드 호출 전후에 별도의 로직을 수행할 수 있다.
- 메서드 호출의 반환값에 변화를 주기 위해 중간에 장식자를 두는 패턴

## 싱글톤 패턴
- private 생성자를 갖는다.
- 단일 객체 참조 변수를 정적 속성으로 갖는다.
- 단일 객체 참조 변수가 참조하는 단일 객체를 반환하는 getInstance() 정적 메서드를 갖는다.
- 단일 객체는 쓰기 가능한 속성을 갖지 않는 것이 정석이다.
- 클래스의 인스턴스, 즉 객체를 하나만 만들어서 사용하는 패턴(인스턴스를 하나만 만들고 그것을 재사용)

## 템플릿 메서드 패턴
- 상위 클래스에 공통 로직을 수행하는 템플릿 메서드와 하위 클래스에 오버라이딩을 강제하는 추상 메서드 또는 선택적으로 오버라이딩할 수 있는 훅(Hook) 메서드를 두는 패턴
- 템플릿 메서드: 공통 로직을 수행, 로직 중에 하위 클래스에서 오버라이딩한 추상 메서드/훅 메서드를 호출
- 템플릿 메서드에서 호출하는 추상 메서드: 하위 클래스가 반드시 오버라이딩해야 한다.
- 템플릿 메서드에서 호출하는 훅(Hook, 갈고리) 메서드: 하위 클래스가 선택적으로 오버라이딩한다.
- 상위 클래스의 견본 메서드에서 하위 클래스가 오버라이딩한 메서드를 호출하는 패턴

## 팩터리 메서드 패턴
- 팩터리 메서드는 객체를 생성 반환하는 메서드를 말한다. 하위 클래스에서 팩터리 메서드를 오버라이딩해서 객체를 반환하게 하는 것
- 오버라이드된 메서드가 객체를 반환하는 패턴

## 전략 패턴
- 클라이언트가 전략을 생성해 전략을 실행할 컨텍스트에 주입하는 패턴
  - 전략 메서드를 가진 전략 객체
  - 전략 객체를 사용하는 컨텍스트(전략 객체의 사용자/소비자)
  - 전략 객체를 생성해 컨텍스트에 주입하는 클라이언트(제3자, 전략 객체의 공급자)

## 템플릿 콜백 패턴
- 전략 패턴의 변형으로, DI(의존성 주입)에서 사용하는 특별한 형태의 전략 패턴
- 전략을 익명 내부 클래스로 정의해서 사용한다는 것이 특징
- 전략을 익명 내부 클래스로 구현한 전략 패턴

